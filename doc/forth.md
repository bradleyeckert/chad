# Differences from ANS Forth

A lot fewer words. You can define an ANS Forth in `chad`, but why?
Code space is limited on purpose. Don't clutter it up with stuff you
don't need. If your code needs an ANS word then copy and paste.
There is so much beautiful ANS Forth code out there.
You don't have to reinvent the wheel, but you do have to think.

## Documentation

`chad` builds its own documentation.
All input source from a text file is rendered in hyperlinked HTML.
The links point to reference documents generated by `chad` with some help
from wiki files.

An important feature of `\` is the optional reference field.
If you want a word to have a reference number for documentation,
use the format `\ x.xxxx yyyyyyyyyy` where `x.xxxx` is a reference number
that you assign and `yyyyyyyyyy` is a stack picture.
A second `\` after `yyyyyyyyyy` begins a comment to end-of-line.
The `x.xxxx` identifier is also used in the wiki text file to mark
the documentation text that will be used to populate the HTML reference.
The order of the wiki document doesn't matter.
Each identifier is searched for from the beginning of the document.
See the `myapp` demo for an example of how this is used.
You would use similar folders for your projects.

The reference documents are generated by wordlist.
If you want the app to have its own reference document, put it in a new
wordlist (or `lexicon`) separate from Forth.

## Compilation

- `:` *( <name> -- )* Starts a definition. The stack is not changed.
- `;` *( -- )* Finishes a definition.

`;` in immediate mode does not compile a return.
This allows the definition to fall through to the next definition.
Forths that separate code and header spaces allow this Non-ANS trick.

## Forward references

Rather than use DEFER and IS for forward references, we use:

- `later` *( <name> -- )* Defines a forward reference.
- `resolves` *( xt <name> -- )* Resolves a forward reference.

Forward references are compiled as a single `jmp` instruction whose
address is resolved by `resolves`.

## Wordlist management

- `empty` *( -- )* Empties the dictionary.
- `lexicon` *( <name> -- )* --> name *( -- wid )* Defines a named wordlist.
- `root` *( -- wid )* The root wordlist.
- `asm` *( -- wid )* The assembler wordlist.
- `_forth` *( -- wid )* The Forth wordlist.
- `forth` *( -- )* Replaces the top of the search order with `forth`.
- `only` *( -- )* Sets the search order to "root forth".
- `also` *( -- )* Duplicates the top of the search order.
- `previous` *( -- )* Drops the top of the search order.

`lexicon` is similar to "WORDLIST CONSTANT" but it also saves the name
so that `order` lists it.
The host's version of `wordlist` is not usable in definitions.
Instead, `lexicon` is provided.

`only` sets the search order to "root forth" so to differentiate between
host words (in `root`) and loaded definitions (in `forth`).
You can list different sets of words by typing:

- `forth words`
- `assembler words`
- `only previous words`

To put definitions in a new wordlist, you can:

```
lexicon myvoc
myvoc +order definitions
( definitions go here )
previous definitions
```

## Floating point numbers

Floats are a compile option: See `HASFLOATS` in `config.h`.
If `HASFLOATS` is defined, numbers are treated as floating point if `base` = 10
and the number contains an `e` or `E`.

IEEE754-like numbers are packed into a double cell on the data stack.
If cells are 16-bit, the format matches 32-bit IEEE754 floats.
The sign, exponent, and mantissa are packed into a double cell.
The exponent and mantissa are resized.
You can change the exponent size to trade dynamic range for precision.

- `set-expbits` *( n -- )* Sets the number of bits in the exponent. Default = 8.
- `f.` *( d -- )* Prints the number represented by *d*.

## Lookup tables in code space

- `|bits|` *( n -- )* Sets the number of bits your lookup table will need.
- `|` *( n -- )* Compiles literal instruction(s) with the RET bit set.

Code space is not randomly readable.
That's a nice security feature if you can keep the ROM image secret.
It also simplifies the CPU design.
As a result, some words for building lookup tables are added.

Lookup tables that aren't in data space are built with code.
Notice the fall-through of exec2:.

```forth
: exec2: 2* [ ;       \ for list of 2-cell literals
: exec:  2* r> + >r ; \ for list of 1-cell literals

16 |bits|
: table  exec2: [ 123 | 456 | 789 | 321 ] literal ;
11 |bits|
: table1  exec: [ 123 | 456 | 789 | 321 ] literal ;
cellbits |bits|
```

## Lookup tables in data space

Tables in data space are classic Forth.
Cross compilers call it IDATA, but no need here.
Hardware (or code) is expected to initialize data space at startup.
A typical use case would keep initial data in SPI flash
and load it into data space at boot.

## Loading and Saving code and data spaces

- `save-code` *( <filename> -- )* Saves the code space to a binary file.
- `save-data` *( <filename> -- )* Saves the data space to a binary file.
- `load-code` *( <filename> -- )* Loads the code space from a binary file.
- `load-data` *( <filename> -- )* Loads the data space from a binary file.

The word data types of code and data are simply cast to `char*` so the binary
is not endian-agnostic. This only matters if your desktop is big-endian.
The rest of the world is little-endian.

## Data space usage

Data memory is an exact power of 2 in size.
The number of cells is set in `config.h`.
The corresponding number of bytes is the constant `dm-size`.

| Field                     | Name   | Size      | Cell Address         |
| ------------------------- | ------ | ---------:| --------------------:|
| Text input buffer         | tib    | 80 bytes  | Top of RAM           |
| Frame stack               | frp0   | 128 cells | grows down from frp0 |
| Numeric conversion region |        |           |                      |
| ...                       | ...    |  ...      | ...                  |
| Compile state             | state  |  1 cell   | 26                   |
| WID of current definition | current|  1 cell   | 25                   |
| Search order              | order  |  8 cells  | 17                   |
| Depth of search order     | orders |  1 cell   | 16                   |
| Wordlist table            | wids   |  8 cells  |  6                   |
| Number radix              | base   |  1 cell   |  5                   |
| Code pointer              | cp     |  1 cell   |  4                   |
| Data pointer              | dp     |  1 cell   |  3                   |
| Address of `tib`          | 'tib   |  1 cell   |  2                   |
| Bytes in `tib`            | tibs   |  1 cell   |  1                   |
| Index into `tib`          | >in    |  1 cell   |  0                   |

The lowest 26 cells of memory are fixed because they are shared with the
host interpreter.

The frame stack grows upward.
The top of `fpad` is also used for numeric conversion, which grows downward.

## Flash memory copy of header space

To have a Forth interpreter on the target, a header data structure must
be built in flash. Wordlists use the same 8-bit identifiers as in `chad`.
Host-side compilation semantics are translated to target-side equivalents.
This structure should be extensible: Each wordlist has a pointer in RAM.
The wordlist pointers are held in data space, to be initialized at bootup.

The structure of headers is based on bytes and cells where cell data is
packed into the least number of bytes (M) that fits it.
Memory used by headers is byte-addressable.
Links are relative to the beginning of header space.
A header contains:

| Length  | Name  | Usage                |
| ------- |:-----:| --------------------:|
| M bytes | link  | Link to next header  |
| 1 byte  | N     | Length of `name`     |
| N bytes | name  | Name string          |
| M bytes | w     | Optional data        |
| M bytes | xte   | *xt* for Execution   |
| M bytes | xtc   | *xt* for Compilation |
| 1 byte  | app   | Applet data          |
| 1 byte  | flags | Packed flags (0=on)  |
| 1 byte  | len   | Length of definition |
| M bytes | forg  | Flash address        |

Flags:

- 0: notail, 0 = no tail recursion allowed
- 1: flashed, 0 = header has fields for *len* and *forg*
- 7: smudge, 1 = smudged

The first header in a list has a link value of 0.
The list name is placed directly before the list using this format:

| Length  | Usage                |
| ------- | --------------------:|
| N bytes | Name string          |
| 1 byte  | Length of name       |
| x bytes | Headers start here   |

## Target compilation

I/O registers are used to write to code space.
Code RAM is writable but not randomly readable.
You can't `see` a compiled word unless it has been copied to flash memory
for later loading into code RAM.
The `forg` field points to the flash version.
If `len` is 0, `forg` may be omitted.

## Frame stack

The frame stack is a fundamental feature of the system. It allows library code
to avoid overflowing the stacks, which are limited by hardware.
It is also used for other things, so it's roomy (128 cells or more).
For example, ROLL can use the frame stack primitives.

### Locals

An important use of the frame stack is local variables.
Locals as defined by the ANS Forth standard are not really applicable to `chad`.
Those kinds of locals are useful for Windows/Unix API calls, not embedded programming.
Chuck Moore calls locals a crutch. Experienced Forth programmers who have implemented
locals in their embedded Forths often end up not using them.
ANS Forth locals are nice, but their scope is limited to the current definition.
They are practically syntactic sugar.

How about a scope that encompasses several definitions?
The scheme must be portable to ANS Forth.
This one is simple and encapsulates private words.
The proposed lexicon is:

- `module` begins a locals scope and adds it to the search order
- `exportable` puts definitions in the wordlist that was being used before `module`
- `end-module` ends a locals scope and removes it from the search order
- `local <name>` defines a word whose run-time action pushes an address onto the data stack
- `n m /locals` moves `n` cells onto the frame stack and reserves `m` cells of extra space
- `[local]` returns the address of the extra space (if any)

Example:

```
module
local foo
local bar
: first foo ? ;  / private words
: second bar ? ;
exportable
: test1 ( bar foo -- ) 2 0 /locals foo bar locals/ ;
: test2 ( bar foo -- ) 2 0 /locals bar foo locals/ ;
end-module 
```

`foo` compiles as a literal (index into the frame stack) and a call to `(local)`
which could be defined as `: (local) invert cells frp @ + ;`.
A 3-cell frame could look like:

```
33 22 11 3
  fp ------^
```

The order of locals is backwards, like ANS Forth, due to the way stacks work.
Any extra allocated locals space is in low memory.
The last cell on the frame stack is the size of the frame in cells.
It is used by `locals/` to discard the frame.

For testing, the names of the locals will be gone from the search order.
You can still get the address with things like `1 (local)` for `foo` etc.
The size of the current stack frame is `0 (local) @`.

## Applets

The usual way to handle large programs is to provide a large memory from which
to execute. Although execution from SPI flash is a possibility, it breaks the
encryption scheme. Code would have to be plaintext.
So, SPIF (the flash controller) doesn't support that.

Instead, the application reserves a section of code RAM for applets.
Conceptually, an applet is a chunk of code in manually managed cache.
When applet functionality is needed, its code is loaded from flash
in a manner very similar to the boot load. SPIF does the transfer in hardware.
Software can either spin until the load is finished or do something useful.
After loading, the applet's API can be used to do whatever is needed.

This scheme works well for applet code. Applet data is another matter because
it would need a write-back mechanism to work like a proper cache.
The alternative is to keep long-lived data in normal variables and allow short-lived
data to be cached without write-back.
Local variables could be used for temporary state.

The variable `apipage` holds the current applet IDs, which is its flash page number.
A page in flash is 256 bytes.
Calls to words in an applet are prepended by a page number literal and a call to (API)
which 32 bits of extra overhead, but it guarantees that the code cache contains the
correct code.

When an applet is defined, CP and DP are saved (so they aren't affected) and set to
the static code and data cache areas in the RAMs.
These are placed at the tops of the code and data RAMs respectively.
`end-applet` saves the applet's code and data to flash at the specified page.

- `applet` *( page -- )* starts a new applet.
- `end-applet` *( -- )* ends the applet and restores the old CP and DP.
- `paged` *( -- page )* returns the next applet page.

For the first applet, manually choose a free page in flash.
For subsequent applets, `paged` will return the next free page.

## Securing the terminal (to be implemented)

Cybersecurity advisories are starting to address things like terminal access.
If the system is accessed over Ethernet, a Telnet to UART bridge could handle encryption.

### Password protection

Boot up with the search order containing only a `public` vocabulary that contains very
few words. One of these is `login`, which accepts a password.
Once logged in, `logout` and `change-password` would be visible.
