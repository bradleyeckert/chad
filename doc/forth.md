# Differences from ANS Forth

A lot fewer words. You can define an ANS Forth in `chad`, but why?
Code space is limited on purpose. Don't clutter it up with stuff you
don't need. If your code needs an ANS word, then copy and paste.
There is so much beautiful ANS Forth code out there.
You don't have to reinvent the wheel, but you do have to think.

## Documentation

`chad` builds its own documentation.
All input source from a text file is rendered in hyperlinked HTML.
The links point to reference documents generated by `chad` with some help
from wiki files.

An important feature of `\` is the optional reference field.
If you want a word to have a reference number for documentation,
use the format `\ x.xxxx yyyyyyyyyy` where `x.xxxx` is a reference number
that you assign and `yyyyyyyyyy` is a stack picture.
A second `\` after `yyyyyyyyyy` begins a comment to end-of-line.
The `x.xxxx` identifier is also used in the wiki text file to mark
the documentation text that will be used to populate the HTML reference.
The order of the wiki document doesn't matter.
Each identifier is searched for from the beginning of the document.
See the `myapp` demo for an example of how this is used.
You would use similar folders for your projects.

The reference documents are generated by wordlist.
If you want the app to have its own reference document, put it in a new
wordlist (or `lexicon`) separate from Forth.

## Compilation

- `:` *( <name> -- )* Starts a definition. The stack is not changed.
- `;` *( -- )* Finishes a definition.

`;` in immediate mode does not compile a return.
This allows the definition to fall through to the next definition.
Forths that separate code and header spaces allow this Non-ANS trick.

## Forward references

Rather than use DEFER and IS for forward references, we use:

- `later` *( <name> -- )* Defines a forward reference.
- `resolves` *( xt <name> -- )* Resolves a forward reference.

Forward references are compiled as a single `jmp` instruction whose
address is resolved by `resolves`.

## Wordlist management

- `empty` *( -- )* Empties the dictionary.
- `lexicon` *( <name> -- )* --> name *( -- wid )* Defines a named wordlist.
- `root` *( -- wid )* The root wordlist.
- `asm` *( -- wid )* The assembler wordlist.
- `_forth` *( -- wid )* The Forth wordlist.
- `forth` *( -- )* Replaces the top of the search order with `forth`.
- `only` *( -- )* Sets the search order to "root forth".
- `also` *( -- )* Duplicates the top of the search order.
- `previous` *( -- )* Drops the top of the search order.

`lexicon` is similar to "WORDLIST CONSTANT" but it also saves the name
so that `order` lists it.
The host's version of `wordlist` is not usable in definitions.
Instead, `lexicon` is provided.

`only` sets the search order to "root forth" so to differentiate between
host words (in `root`) and loaded definitions (in `forth`).
You can list different sets of words by typing:

- `forth words`
- `assembler words`
- `only previous words`

To put definitions in a new wordlist, you can:

```
lexicon myvoc
myvoc +order definitions
( definitions go here )
previous definitions
```

## Floating point numbers

Floats are a compile option: See `HASFLOATS` in `config.h`.
If `HASFLOATS` is defined, numbers are treated as floating point if `base` = 10
and the number contains an `e` or `E`.

IEEE754-like numbers are packed into a double cell on the data stack.
If cells are 16-bit, the format matches 32-bit IEEE754 floats.
The sign, exponent, and mantissa are packed into a double cell.
The exponent and mantissa are resized.
You can change the exponent size to trade dynamic range for precision.

- `set-expbits` *( n -- )* Sets the number of bits in the exponent. Default = 8.
- `f.` *( d -- )* Prints the number represented by *d*.

## Lookup tables in code space

- `|bits|` *( n -- )* Sets the number of bits your lookup table will need.
- `|` *( n -- )* Compiles literal instruction(s) with the RET bit set.

Code space is not randomly readable.
That's a nice security feature if you can keep the ROM image secret.
It also simplifies the CPU design.
As a result, some words for building lookup tables are added.

Lookup tables that aren't in data space are built with code.
Notice the fall-through of exec2:.

```forth
: exec2: 2* [ ;       \ for list of 2-cell literals
: exec:  2* r> + >r ; \ for list of 1-cell literals

16 |bits|
: table  exec2: [ 123 | 456 | 789 | 321 ] literal ;
11 |bits|
: table1  exec: [ 123 | 456 | 789 | 321 ] literal ;
cellbits |bits|
```

## Lookup tables in data space

Tables in data space are classic Forth.
Cross compilers call it IDATA, but no need here.
Hardware (or code) is expected to initialize data space at startup.
A typical use case would keep initial data in SPI flash
and load it into data space at boot.

## Loading and Saving code and data spaces

- `save-code` *( <filename> -- )* Saves the code space to a binary file.
- `save-data` *( <filename> -- )* Saves the data space to a binary file.
- `load-code` *( <filename> -- )* Loads the code space from a binary file.
- `load-data` *( <filename> -- )* Loads the data space from a binary file.

The word data types of code and data are simply cast to `char*` so the binary
is not endian-agnostic. This only matters if your desktop is big-endian.
The rest of the world is little-endian.

## Data space usage

Data memory is an exact power of 2 in size.
The number of cells is set in `config.h`.
The corresponding number of bytes is the constant `dm-size`.

| Field             | Name  | Size     | Address    |
| ----------------- | ----- | --------:| ----------:|
| Text input buffer | tib   | 80 bytes | Top of RAM |
| Frame stack       | fpad  | 64 cells |            |
| ...               | ...   |  ...     | ...        |
| Bytes in `tib`    | tibs  |  1 cells | 4 cells    |
| Index into `tib`  | >in   |  1 cells | 3 cells    |
| Compile state     | state |  1 cells | 2 cells    |
| Number radix      | base  |  1 cells | 1 cells    |
| Data pointer      | dp    |  1 cells | 0 cells    |

The lowest 5 cells of memory are fixed because they are shared with the
host interpreter.

The frame stack grows upward.
The top of `fpad` is also used for numeric conversion, which grows downward.

## Flash memory copy of header space

To have a Forth interpreter on the target, a header data structure must
be built in flash. Wordlists use the same 8-bit identifiers as in `chad`.
Host-side compilation semantics are translated to target-side equivalents.
This structure should be extensible: Each wordlist has a pointer in RAM.
The wordlist pointers are held in data space, to be initialized at bootup.

The structure of headers is based on bytes and cells where cell data is
packed into the least number of bytes (M) that fits it.
Memory used by headers is byte-addressable.
Links are relative to the beginning of header space.
A header contains:

| Length  | Name  | Usage                |
| ------- |:-----:| --------------------:|
| M bytes | link  | Link to next header  |
| 1 byte  | N     | Length of `name`     |
| N bytes | name  | Name string          |
| M bytes | w     | Optional data        |
| M bytes | xte   | *xt* for Execution   |
| M bytes | xtc   | *xt* for Compilation |
| 1 byte  | app   | Applet data          |
| 1 byte  | flags | Packed flags (0=on)  |
| 1 byte  | len   | Length of definition |
| M bytes | forg  | Flash address        |

Flags:

- 0: notail, 0 = no tail recursion allowed
- 1: flashed, 0 = header has fields for *len* and *forg*
- 7: smudge, 1 = smudged

The first header in a list has a link value of 0.
The list name is placed directly before the list using this format:

| Length  | Usage                |
| ------- | --------------------:|
| N bytes | Name string          |
| 1 byte  | Length of name       |
| x bytes | Headers start here   |

## Target compilation

I/O registers are used to write to code space.
Code RAM is writable but not randomly readable.
You can't `see` a compiled word unless it has been copied to flash memory
for later loading into code RAM.
The `forg` field points to the flash version.
If `len` is 0, `forg` may be omitted.

## To Do

Catch and Throw should use the features of `frame.f` to set up `catch` frames.
Maybe leave more stack space for the frame stack in data RAM.

A cooperative multitasker can likewise use `frame.f` words to move hardware
stacks to and from tasks. This makes a context switch more unwieldy, but still
in the microsecond range.

Put a larger data space in the hardware. The code space is 4K x 16.
Data space should be 2K or 4K words.



