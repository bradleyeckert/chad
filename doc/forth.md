# Differences from ANS Forth

A lot fewer words. You can define an ANS Forth in `chad`, but why?
Code space is limited on purpose. Don't clutter it up with stuff you
don't need. If your code needs an ANS word then copy and paste.
There is so much beautiful ANS Forth code out there.
You don't have to reinvent the wheel, but you do have to think.

## Documentation

`chad` builds its own documentation.
All input source from a text file is rendered in hyperlinked HTML.
The links point to reference documents generated by `chad` with some help
from wiki files.

An important feature of `\` is the optional reference field.
If you want a word to have a reference number for documentation,
use the format `\ x.xxxx yyyyyyyyyy` where `x.xxxx` is a reference number
that you assign and `yyyyyyyyyy` is a stack picture.
A second `\` after `yyyyyyyyyy` begins a comment to end-of-line.
The `x.xxxx` identifier is also used in the wiki text file to mark
the documentation text that will be used to populate the HTML reference.
The order of the wiki document doesn't matter.
Each identifier is searched for from the beginning of the document.
See the `myapp` demo for an example of how this is used.
You would use similar folders for your projects.

The reference documents are generated by wordlist.
If you want the app to have its own reference document, put it in a new
wordlist (or `lexicon`) separate from Forth.

## Compilation

- `:` *( <name> -- )* Starts a definition. The stack is not changed.
- `;` *( -- )* Finishes a definition.

`;` in immediate mode does not compile a return.
This allows the definition to fall through to the next definition.
Forths that separate code and header spaces allow this Non-ANS trick.

## Forward references

Rather than use DEFER and IS for forward references, we use:

- `later` *( <name> -- )* Defines a forward reference.
- `resolves` *( xt <name> -- )* Resolves a forward reference.

Forward references are compiled as a single `jmp` instruction whose
address is resolved by `resolves`.

## Wordlist management

- `empty` *( -- )* Empties the dictionary.
- `lexicon` *( <name> -- )* --> name *( -- wid )* Defines a named wordlist.
- `root` *( -- wid )* The root wordlist.
- `asm` *( -- wid )* The assembler wordlist.
- `_forth` *( -- wid )* The Forth wordlist.
- `forth` *( -- )* Replaces the top of the search order with `forth`.
- `only` *( -- )* Sets the search order to "root forth".
- `also` *( -- )* Duplicates the top of the search order.
- `previous` *( -- )* Drops the top of the search order.

`lexicon` is similar to "WORDLIST CONSTANT" but it also saves the name
so that `order` lists it.
The host's version of `wordlist` is not usable in definitions.
Instead, `lexicon` is provided.

`only` sets the search order to "root forth" so to differentiate between
host words (in `root`) and loaded definitions (in `forth`).
You can list different sets of words by typing:

- `forth words`
- `assembler words`
- `only previous words`

To put definitions in a new wordlist, you can:

```
lexicon myvoc
myvoc +order definitions
( definitions go here )
previous definitions
```

## Floating point numbers

Floats are a compile option: See `HASFLOATS` in `config.h`.
If `HASFLOATS` is defined, numbers are treated as floating point if `base` = 10
and the number contains an `e` or `E`.

IEEE754-like numbers are packed into a double cell on the data stack.
If cells are 16-bit, the format matches 32-bit IEEE754 floats.
The sign, exponent, and mantissa are packed into a double cell.
The exponent and mantissa are resized.
You can change the exponent size to trade dynamic range for precision.

- `set-expbits` *( n -- )* Sets the number of bits in the exponent. Default = 8.
- `f.` *( d -- )* Prints the number represented by *d*.

## Lookup tables in code space

- `|bits|` *( n -- )* Sets the number of bits your lookup table will need.
- `|` *( n -- )* Compiles literal instruction(s) with the RET bit set.

Code space is not randomly readable.
That's a nice security feature if you can keep the ROM image secret.
It also simplifies the CPU design.
As a result, some words for building lookup tables are added.

Lookup tables that aren't in data space are built with code.
Notice the fall-through of exec2:.

```forth
: exec2: 2* [ ;       \ for list of 2-cell literals
: exec:  2* r> + >r ; \ for list of 1-cell literals

16 |bits|
: table  exec2: [ 123 | 456 | 789 | 321 ] literal ;
11 |bits|
: table1  exec: [ 123 | 456 | 789 | 321 ] literal ;
cellbits |bits|
```

## Lookup tables in data space

Tables in data space are classic Forth.
Cross compilers call it IDATA, but no need here.
Hardware (or code) is expected to initialize data space at startup.
A typical use case would keep initial data in SPI flash
and load it into data space at boot.

## Loading and Saving code and data spaces

- `save-code` *( <filename> -- )* Saves the code space to a binary file.
- `save-data` *( <filename> -- )* Saves the data space to a binary file.
- `load-code` *( <filename> -- )* Loads the code space from a binary file.
- `load-data` *( <filename> -- )* Loads the data space from a binary file.

The word data types of code and data are simply cast to `char*` so the binary
is not endian-agnostic. This only matters if your desktop is big-endian.
The rest of the world is little-endian.

## Data space usage

Data memory is an exact power of 2 in size.
The number of cells is set in `config.h`.
The corresponding number of bytes is the constant `dm-size`.

| Field                     | Name   | Size      | Cell Address         |
| ------------------------- | ------ | ---------:| --------------------:|
| Text input buffer         | tib    | 80 bytes  | Top of RAM           |
| Frame stack               | frp0   | 128 cells | grows down from frp0 |
| Numeric conversion region |        |           |                      |
| ...                       | ...    |  ...      | ...                  |
| Compile state             | state  |  1 cell   | 26                   |
| WID of current definition | current|  1 cell   | 25                   |
| Search order              | order  |  8 cells  | 17                   |
| Depth of search order     | orders |  1 cell   | 16                   |
| Wordlist table            | wids   |  8 cells  |  6                   |
| Number radix              | base   |  1 cell   |  5                   |
| Code pointer              | cp     |  1 cell   |  4                   |
| Data pointer              | dp     |  1 cell   |  3                   |
| Address of `tib`          | 'tib   |  1 cell   |  2                   |
| Bytes in `tib`            | tibs   |  1 cell   |  1                   |
| Index into `tib`          | >in    |  1 cell   |  0                   |

The lowest 26 cells of memory are fixed because they are shared with the
host interpreter.

The frame stack grows upward.
The top of `fpad` is also used for numeric conversion, which grows downward.

## Flash memory copy of header space

To have a Forth interpreter on the target, a header data structure must
be built in flash. Wordlists use the same 8-bit identifiers as in `chad`.
Host-side compilation semantics are translated to target-side equivalents.
This structure should be extensible: Each wordlist has a pointer in RAM.
The wordlist pointers are held in data space, to be initialized at bootup.

The structure of headers is based on bytes and cells where cell data is
packed into the least number of bytes (M) that fits it.
Memory used by headers is byte-addressable.
Links are relative to the beginning of header space.
A header contains:

| Length  | Name  | Usage                |
| ------- |:-----:| --------------------:|
| M bytes | link  | Link to next header  |
| 1 byte  | N     | Length of `name`     |
| N bytes | name  | Name string          |
| M bytes | w     | Optional data        |
| M bytes | xte   | *xt* for Execution   |
| M bytes | xtc   | *xt* for Compilation |
| 1 byte  | app   | Applet data          |
| 1 byte  | flags | Packed flags (0=on)  |
| 1 byte  | len   | Length of definition |
| M bytes | forg  | Flash address        |

Flags:

- 0: notail, 0 = no tail recursion allowed
- 1: flashed, 0 = header has fields for *len* and *forg*
- 7: smudge, 1 = smudged

The first header in a list has a link value of 0.
The list name is placed directly before the list using this format:

| Length  | Usage                |
| ------- | --------------------:|
| N bytes | Name string          |
| 1 byte  | Length of name       |
| x bytes | Headers start here   |

## Target compilation

I/O registers are used to write to code space.
Code RAM is writable but not randomly readable.
You can't `see` a compiled word unless it has been copied to flash memory
for later loading into code RAM.
The `forg` field points to the flash version.
If `len` is 0, `forg` may be omitted.

## Frame stack

The frame stack is a fundamental feature of the system. It allows library code
to avoid overflowing the stacks, which are limited by hardware.
It is also used for other things, so it's roomy (128 cells or more).
For example, ROLL can use the frame stack primitives.

### Locals (to be implemented)

An important use of the frame stack is local variables.
Locals as defined by the ANS Forth standard are not really applicable to `chad`.
Those kinds of locals are useful for Windows/Unix API calls, not embedded programming.
Chuck Moore calls locals a crutch. Experienced Forth programmers who have implemented
locals in their embedded Forths end up not using them.
ANS Forth locals are nice, but their scope is limited to the current definition.
They are practically syntactic sugar.

How about a scope that encompasses several definitions?
The scheme must be portable to ANS Forth.
The proposed lexicon is:

- `begin-locals` begins a locals scope and adds it to the search order
- `end-locals` ends a locals scope and removes it from the search order
- `local <name>` defines a word whose run-time action pushes an address onto the data stack
- `n m frame` moves `n` cells onto the frame stack and reserves `m` cells of extra space
- `[local]` returns the address of the extra space (if any)

```
begin-locals
local foo
local bar

: first foo ? ;
: second bar ? ;
: third ( bar foo -- ) 2 0 frame foo bar unframe ;
end-locals 
```

`foo` compiles as a literal (index into the frame stack) and a call to `(local)`
which could be defined as `: (local) invert cells frp @ + ;`.
A 3-cell frame could look like:

```
33 22 11 3
  fp ------^
```

The order of locals is backwards, like ANS Forth, due to the way stacks work.
Any extra allocated locals space is in low memory.
The last cell on the frame stack is the size of the frame in cells.
It is used by `unframe` to discard the frame.

For testing, the names of the locals will be gone from the search order.
You can still get the address with things like `1 (local)` for `foo` etc.
The size of the current stack frame is `0 (local) @`.

## Applets (to be implemented)

The usual way to handle large programs is to provide a large memory from which
to execute. Although execution from SPI flash is a possibility, it breaks the
encryption scheme. Code would have to be plaintext.
So, SPIF (the flash controller) doesn't support that.

Instead, the application reserves sections of code and data RAM for applets.
Conceptually, an applet is a chunk of code in manually managed cache.
When applet functionality is needed, its code and data are loaded from flash
in a manner very similar to the boot load. SPIF does the transfer in hardware.
Software can either spin until the load is finished or do something useful.
After loading, the applet's API can be used to do whatever is needed.

A global variable holds the previous and current applet IDs,
which can be the applet's flash memory 4K sector number. 
That as well as an API call ID can be packed into a literal,
which is pushed onto the stack before calling
`aplfn`. `aplfn` checks if the applet is in code memory.
If a different applet is there, it saves the new applet's ID and loads it from flash.
This conceptually similar to a "cache miss".

While a normal Forth would put immediate data right after the call and manipulate the
return stack to get it, code space is unreadable for security reasons.
So, the data is just passed on the stack as a literal.
Applets will be aligned on 4K boundaries to match the flash sector size.
An 11-bit literal can pack a 6-bit sector number and a 5-bit call ID.
That allows for a 256 KB of applet storage and 32 different API calls per applet.
`aplfn` jumps to the location in applet code indexed by call ID.
The code at that location is a jump instruction.

If `aplfn` handles a cache miss (before jumping to the code), after that code returns
control to `aplfn` the previous applet is restored so that the code after it is safe.
So, applets can call other applets and still use normal jumps and calls internally.
The data space of applets is a different story.
Global variables used by applets can be trashed unless saved.
The easiest solution to the problem is to not put long-term data in applets.
Use handles for that.

An example of an applet is a file system.
It may use 2KB of code space, which would load in 150 usec when decrypting
using a 100 MHz clock.
Compare to a sector read of a SD card in SPI mode: 25 MBPS x 4096 bits = 164 usec.
The file system could be distributed among several applets to optimize the load time.

A historical analog can be seen in the Europay Smart Card payment system.
It operated over POTS phone lines and used MCUs from the 2000 time frame
to implement a Forth token interpreter.
Within that severely constrained environment, load-on-demand applets worked very well.
Chad's load rate and execution speed are a couple of orders of magnitude faster
than what Europay had to work with.

## Securing the terminal (to be implemented)

Cybersecurity advisories are starting to address things like terminal access.
If the system is accessed over Ethernet, a Telnet to UART bridge could handle encryption.

### Password protection

Boot up with the search order containing only a `public` vocabulary that contains very
few words. One of these is `login`, which accepts a password.
Once logged in, `logout` and `change-password` would be visible.
