# Using TFT LCD displays

Small color graphic LCD modules for embedded projects range from 128x160
to 320x480. Popular sizes are 240x320 (QVGA), controlled by the ILI9341,
and 320x480 (HVGA), controlled by the ILI9488.

`TFTsim.c` simulates a TFT controller chip by plotting pixels to a BMP data
structure. The same 24-bit BMP you see when you look at the binary of a BMP
file. In graphics programming, it's not much to plop a BMP up on the screen.
Once the app calls `TFTLCDsetup` to assign the BMP and module size,
Chad can write to the simulated LCD using `io!` to a single address.

## Driving an ILI9341 or ILI9388

The ILI9341 is the controller on most 240 x 320 TFT displays.
The data bus can be 8, 9, 16, or 18 bits.

A Wishbone Bus interface is used to implement the controller interface.
TFTLCDgram handles splitting GRAM data into multiple write cycles when the
TFT module's bus width is less than 18-bit.

|Reg|Name         |Function                                    |
|---|:-----------:|-------------------------------------------:|
|10h|TFTLCDcommand|Writes 8-bit data with the D/CX pin at '0'. |
|11h|TFTLCDdata   |Writes 8-bit data with the D/CX pin at '1'. |
|12h|TFTLCDend    |Deactivates the CS pin.                     |
|13h|TFTLCDgram   |Writes 18-bit data with the D/CX pin at '1'.|

If a new write is requested before the previous one is finished, the Wishbone
bus will wait until the hardware is ready.

## A graphics programming paradigm for color TFTs.

Graphic primitives are optimized for use with ILI9341 (etc.) commands.
Graphics are drawn by setting the limits for a rectangular drawing area and
pouring a raster of pixels into that area. The commands used are:

- Column Address Set (2Ah)
- Page Address Set (2Bh)
- Memory Write (2Ch)

To pop up a message window or draw a new region of text, you would start by
clearing the region with a rectangular fill command.
Then you would paint characters on that blank background.

## Text rendering

The primary use of the panel is text display from fonts stored in SPI flash.
Fonts are stored in bitmap format using a suitable compression.

The bitmap datastream is 8-bit, generated by `spif.v`. Hardware can stream bytes
from flash to the LCD without CPU intervention. It makes sense, then, to design
a compression method around bytes.

There are two 18-bit colors, `fgcolor` and `bgcolor` registers that store
foreground and background colors in 6:6:6 RGB format.
The 4-bit grayscale is used to interpolate between the two:
`0000` is the background and `1111` is the foreground.
With `g` as the grayscale, each color plane is:

```
R = (Rf*g + Rb*(~g)) >> 4
G = (Gf*g + Gb*(~g)) >> 4
R = (Bf*g + Bb*(~g)) >> 4
```

### Token codes

Fonts and icons are encoded using 16-bit commands that create runs of pixels
with appropriate color depths. The fonts are stored in SPI flash.
The 16-bit words can be streamed out to a hardware implementation of the interpreter
of read into a software version that writes to the LCD panel. The tokens are:

- `DIRECT  0000xxrd_dddddddd`  Reserved for direct control of data bus, r is RS bit.
- `BGCOLOR 00010000_00dddddd`  Load background color
- `FGCOLOR 00010000_01dddddd`  Load foreground color
- `MODE    00010000_1000dddd`  Load mode
- `PERIOD  00010000_1001dddd`  Load period
- `WRHIGH  00010000_1010dddd`  Load write trailing edge position
- `MONOCT  001nnnnx_xxxxxxxx`  Output 0 to 9 monochrome pixels, LSB first.
- `MONO01  0100aaaa_aabbbbbb`  Output a BG pixels followed by b FG pixels.
- `GRAY0   01010ggg_gccccccc`  Output 4-bit g pixel followed by up to 127 BG pixels
- `GRAY1   01011ggg_gccccccc`  Output 4-bit g pixel followed by up to 127 FG pixels
- `SETRG   0110rrrr_rrgggggg`  Color pixel prefix: RG
- `RGBRUN  0111cccc_ccbbbbbb`  Output RGB pixel with repeat counter up to 127
- `MONO15  1xxxxxxx_xxxxxxxx`  Output 15 monochrome pixels, LSB first.

The cost to interpret tokens in hardware (MAX10) is 345 LEs and 145 registers.
What do we gain from this compared to a software implementation?
The inner loops of most tokens are pretty tight - they just repeat the pixel.
Grayscale is the exception because it uses six multiplies in the interpolation.
At 80 gray pixels per character and 300 cycles per interpolation, a 15 x 20 glyph
may need 3000 cycles for non-gray and 24000 cycles for gray pixels.
Clearly, hardware acceleration is desired for interpolation.

The hardware version provides wiring flexibility.
It may take 1, 2, or 3 write cycles to write a pixel depending on bus width and mode.
Some representative screen fill times at 80ns per write cycle:

- QVGA (240x320): 6ms, 12ms, 18ms
- HVGA (320x480): 12ms, 24ms, 37ms

An 8-bit or 9-bit bus is all that's needed. A wider bus just wastes pins.
Many TFT LCD vendors offer a 16-bit or 18-bit bus and the IM pins so you can
select the bus width you want. When starting a project, use one of these even
though the FPC connector is bigger. You can always downsize the tail if volumes
justify it.

The MODE setting depends on the LCD module's data bus width.
Set it to match that and the color depth (16-bit or 18-bit).

- `0000` 18-bit: Three bytes representing R, G, and B.
- `0100` 16-bit: Two bytes representing 5:6:5 color format.
- `1000` 18-bit: Two 9-bit words representing 6:6:6 color format.
- `1010` 16-bit: One 16-bit word representing 5:6:5 color format.
- `1011` 18-bit: Two 16-bit words representing 6:6:6 color format.
- `1110` 18-bit: One 18-bit word representing 6:6:6 color format.

### Font data

The typical small LCD screen, like a 2.4" QVGA or 3.5" HVGA,
has a dot pitch of 0.15mm, 6.5 DPmm, or 166 DPI.
3.2mm (1/8") of distance is 21 pixels.
There's no point in making the user squint.
The minimum font height should be 16 pixels.
A grayscale bitmap will average 2 to 6 pixels per byte, so a 20x20
character would need something like 100 bytes. 400 glyphs would use 40KB
of SPI flash. Since even 1MB is not much flash, storage isn't a problem.
16MB costs around $1 (in 2020) so an entire Unicode font could fit in NOR flash.

The bitmap data is generated by a font utility and saved in binary format.
The font database can be re-flashed independently of the rest of the flash
to handle updates in message requirements. If the app needs a new glyph, it should
be able to look at the font version number and tell whether it needs an upgrade.

Unicode is arranged as a number of 64-byte pages.
The useful code range is 0021h to 3FFFh.
In flash, there is a 256-entry list of page addresses.
Each entry points to a page table if it's not 0.
The page table contains the size of the table and 
addresses (or offsets to) the bitmap.
Compiling the bitmap text input and populating the tables are done by `chad`.
Bitmap creation is done by the `fonts` utility, which reads a list of all messages,
determines which glyphs are needed, and generates the binary font archive.

## Graphic primitives

The cursor position is in units of pixels. 
When using a fixed font, the cursor steps to the right after each `emit`.
If it has reached the right edge, the cursor goes to the next text line
or stays on the current line if it's at the bottom of the screen.
Scrolling is not supported.

- `gat` *( x y -- )* Sets the upper left corner of the next drawing feature.
- `gsize` *( w h -- )* Sets the size of the drawing area.
- `gat?` *( -- x y )* Reads the current cursor position.
- `gfill` *( color -- )* Rectangular fill with color.
- `>bgcolor` *( color -- )* Set the background color for text rendering.
- `>fgcolor` *( color -- )* Set the foreground color for text rendering.
- `gmono` *( addr -- )* Render bitmap from `addr` in flash memory.
- `gkerning` *( x y -- )* Sets the kerning values used by `gmono`.

The LSB of the first byte is the upper left pixel in the field of `gmono`.

After `gmono` renders a bitmap, it steps the cursor according to the
parameters set by `gsize` and `gkerning`.
Kerning is the amount of spacing between characters.

## Font compiler

A font compiler is used to create bitmaps.
It uses a list of all of the messages in the system to build data structure.
The data structure is expected to fit in a 64KB region.
It starts with a lookup table whose elements point to the character data.
It uses little-endian format and 8-bit bytes.

- 2-byte table size, N
- N x { 2-byte character value, 2-byte index to bitmap }
- N x { 1-byte width, 1-byte height, Bitmap data }

It takes about 10 branches to do a binary lookup.
Random read of flash, even in QSPI mode (command EBh),
requires 40 clock cycles to start the read and then 4 cycles per byte
assuming the SPI clock is half the processor clock.
Jumping around costs you.
It will take about 600 cycles to find the character.
Drawing the character will take 24 cycles per pixel as shown above.
An 8 x 16 field would paint in 2000 cycles, swamping the lookup time.






