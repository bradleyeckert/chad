{ ====================================================================
Bitmap Font creation with 4-bit grayscale support

Render characters in a Win32 graphic window using SwiftForth.
Build a font image in the dictionary and output it in raw binary.
FOSS tools for converting to other formats are:
https://github.com/python-intelhex/intelhex
https://github.com/AntumDeluge/bin2header

Run-length compression using 16-bit tokens is used to optimize storage.
The font is designed to reside in SPI flash, so linear tables are used
for lookup instead of a binary tree since random reads aren't cheap.

An interpreter is implemented in software or hardware to process the
tokens and turn them into bus writes for a ILI9341 or similar LCD
controller. DECOMPRESS is a sample implementation.
==================================================================== }

 6 VALUE PELSIZE
 0 VALUE hDlg
 0 VALUE HDC
: hWnd hDlg ;

DIALOG (CSPEC) [MODELESS " Text Canvas"  5 5  128 160 ]
END-DIALOG

 1 CONSTANT PANES                       \ in the window
16 CONSTANT FONTHT                      \ scale for H1 to H7
INCLUDE GRAPHICS.F                      \ wrapper for Win32 calls

56 constant |X|                         \ dimensions of biggest glyph field
64 constant |Y|

: InitGraf  ( -- )                      \ initialize the graphic pane
   0 0 |X| |Y| HDC hDlg  InitPane
   h4
;

|X| |Y| * constant |XY|
|XY| buffer: pixelfield                 \ raw 4-bit pixel data
|XY| buffer: pixels                     \ cropped pixel data
variable left                           \ crop border
variable right
variable top
variable bottom

create unichar   $22 c, $21 c, 0 ,

: wemit  ( n -- )                       \ render unicode char (0 to 65535)
   unichar w!
   white  |X| |Y| 0 0 Rect              \ clear character field
   0 0 unichar 1 .wtext                 \ render one character into bitmap
;

: capture  ( -- )                       \ capture bitmap to pixels buffer
   |Y| top !  0 bottom !
   |X| left !  0 right !
   |Y| 0 DO  |X| 0 DO
      I J PEL@  4 RSHIFT INVERT 15 AND  \ white background = 0000
      DUP  J |X| *  I +  pixelfield + C!
      IF   top @ J MIN top !
          left @ I MIN left !
        bottom @ J MAX bottom !
         right @ I MAX right !
      THEN
   LOOP LOOP
;
: fwidth   ( -- n )
   right @ 1+ left @ - 0 max ;
: fheight  ( -- n )
   bottom @ 1+ top @ - 0 max ;

: crop  ( -- )                          \ copy AA from pixelfield to pixels
   fheight 0 do
      pixelfield  i top @ + |X| * +  left @ +   \ from
      pixels i fwidth * +  fwidth cmove         \ to
   loop
;

\ ==============================================================================
\ Bitmap compression

\ Input: (addr, len) of a string of 4-bit pixel values

2variable run                           \ length, address   2@ -> ( addr u )
2variable src                           \ final run after a trial

: /comp  ( -- )                         \ set up the compression
   pixels  fwidth fheight *  run 2!
;
: src?  ( cnt -- cnt-1 flag )           \ is there any input left?
   dup 1- swap  src @ 0<> and
;
: src@  ( -- c )                        \ current input shade
   src cell+ @ c@
;
: bump  ( -- )                          \ point to next byte of input
   src 2@  1 /string  src 2!
;
: /src  ( -- )                          \ reset the input stream
   run 2@  src 2!
;
: score  ( -- )                         \ how much input was consumed
   run @  src @  -
;

variable x                              \ data generated by a trial
variable y                              \ 16-bit command generated by a trial

: mono  ( allowed -- actual )           \ try to fit into a 1bpp direct map
   0 x !  /src
   begin  src?  while
      src@  dup 15 =  swap 0=  or 0=  if drop score exit then
      x @ 2/  src@ if $4000 or then     \ shift the pixel into x
      x !  bump
   repeat drop  score
;
: mono15  ( -- length )                 \ it fits in a 15-pixel 1bpp run
   15 mono  dup 15 = and                \ format: 1xxxxxxx_xxxxxxxx
   x @  $8000 or  y !
;
: mono9   ( -- length )                 \ it fits in a 0 to 9 1bpp run
   9 mono                               \ format: 001ccccx_xxxxxxxx
   x @  over 15 swap - rshift
   $2000 or  over 9 lshift or  y !
;
\ 000 is reserved for data format: 000eccrd_dddddddd
\ e = LCT reset; cc = chip select: 10=hi, 11=lo, 01=sleep; r = RS level
: run0  ( maxpels -- )                  \ count the run of 0s
   begin  src?  while  src@
      if drop exit then
      bump
   repeat drop
;
: runF  ( maxpels -- )                  \ count the run of Fs
   begin  src?  while  src@
      15 <> if drop exit then
      bump
   repeat drop
;
: mono01  ( -- length )                 \ 0-63 '0's followed by 0-63 'F's
   /src
   63 run0 score  63 runF score  over - ( 0s 1s )
   2dup + -rot  swap
   6 lshift +  $4000 + y !              \ format: 0100aaaa_aabbbbbb
;
: gray0  ( -- length )                  \ gray scale followed by 0s
   /src  src @ if                       \ format: 01010ggg_gccccccc  gray, 0s
      src@ 7 lshift $5000 or y !
      src@ 1 15 within if               \ starts with gray
         bump  127 run0
      then
   then  score  dup 1- y +!
;
: gray1  ( -- length )                  \ gray scale followed by 1s
   /src  src @ if                       \ format: 01011ggg_gccccccc  gray, Fs
      src@ 7 lshift $5800 or y !
      src@ 1 15 within if               \ starts with gray
         bump  127 runF
      then
   then  score  dup 1- y +!
;

create scores                           \ TRIAL populates the length fields.
( length  xt_try )
  0 ,   ' mono15 ,
  0 ,   ' mono9 ,
  0 ,   ' mono01 ,
  0 ,   ' gray0 ,
  0 ,   ' gray1 ,

5 constant |scores|

: [score]  ( n -- addr )                \ index into scores
   2* cells scores +
;

: trial  ( -- )                         \ try all methods
   |scores| 0 do
      i [score] cell+ @ execute
      i [score] !
   loop
;
: best  ( -- idx )                      \ get the index of the best one
   -1 dup  |scores| 0 do
      i [score] @                       ( idx len len' )
      2dup < if
         nip nip i swap
      else  drop
      then
   loop  drop
;
: command  ( -- u16 )                   \ build the command
   trial  best [score] cell+ @ execute drop
   src 2@  run 2!  y @
;

8192 buffer: compbuf                    \ a place to store the compressed image
: compress  ( -- )                      \ compress the captured bitmap
   /comp /src  0
   begin src @ while
      1+  command  over 2* compbuf + w!
   repeat  compbuf w!                   \ first 16-bit value is the length
;

\ ==============================================================================

: wcount  ( a -- a+2 n )
   dup 2 + swap w@
;

65536 constant |usedchars|
|usedchars| cells buffer: usedchars

: [usedchars]  ( n -- a )
   cells usedchars +
;
: MakeFont  ( -- )
   cr ." Building the font, please wait..."
   |usedchars| 0 ?do
      i [usedchars] @ if
        i wemit capture crop
        fheight if  compress
           here i [usedchars] !         \ save a link to the bitmap being created
           left @ c,  top @ c,
           fwidth c,  fheight c,
           compbuf wcount  dup w,  0 ?do wcount w, loop  drop
           ." ."
        else
           0  i [usedchars] !           \ not a usable character
        then
      then
   loop  ." ok"
;

: /MSG  ( -- )                          \ reset the message list
   usedchars |usedchars| cells erase    \ clear all tags
;
: HasNumeric  ( -- )                    \ tag the numbers
   [char] ; [char] . do                 \ ./0123456789:
      1  i [usedchars] !
   loop
;
: HasASCII  ( -- )                      \ tag ASCII
   128 33 do  1  i [usedchars] !
   loop
;

: HighestChar  ( -- xchar )             \ find the max used xchar
   |usedchars| begin 1- dup while       ( xchar )
      dup [usedchars] @ if exit then
   repeat
;
: #tables  ( -- n )                     \ number of fine tables needed
   HighestChar 6 rshift 1+
;
: finechars  ( xchar -- size )          \ number of chars in fine table
   64 begin 1- dup while                ( xchar size )
      2dup + [usedchars] @ if 1+ nip exit then
   repeat nip
;

\ The structure of the font(s) is:
\
\ Number of fonts (8-bit)
\ Offset to 1st font (24-bit)
\ ...
\ The font data (lots of data)
\ Coarse table: 256 cells indexed by (xchar>>6). 16-bit offsets to fine tables.
\ Fine table 0: Length N followed by N offsets. 24-bit offsets to bitmaps.

0 value FontHome                        \ origin of font data structure

: n,  ( n -- )  , -1 H +! ;             \ compile 24-bit number
: n@  ( -- n )  @ $FFFFFF and ;         \ fetch 24-bit number
: n!  ( n a -- )                        \ store 24-bit number
   dup @ $FF000000 and
   rot   $00FFFFFF and or
   swap !
;
: fhere  ( -- n ) here FontHome - ;     \ relative HERE

: /FONTS  ( n -- )                      \ set the number of fonts being compiled
   here to FontHome  dup c,
   3 * 0 ?do 0 c, loop
;
: ,fine  ( idx -- zero? )
   6 lshift  dup finechars  dup if      ( xchar size )
      dup c,                            \ entries in table = 1 to 64
      0 ?do
         dup [usedchars] @  ?dup if
            FontHome - n,               \ relative to glyph
         else  0 n,                     \ 0 if no glyph
         then  1+
      loop  drop  false
   else  2drop  true                    \ nothing to compile
   then
;

variable 'coarse                        \ -> coarse table
variable FontID                         \ the current font for testing

: MakeTable  ( fontID -- )              \ populate glyph tables for this font
   dup FontID !
   fhere  swap 3 *  FontHome 1+ + n!    \ font[fontID] -> here (the coarse table)
   here 'coarse !
   #tables  dup 2* allot                \ leave space for the tables
   0 ?do
      here 'coarse @ -                  \ offset to fine table
      i ,fine if drop 0 then            \ pointer is 0 if no data
      i 2* 'coarse @ +  w!              \ resolve pointer to fine table
   loop
;

: SAVE  ( <filename> -- )               \ save to binary file
   parse-word w/o create-file throw >r
   FontHome fhere r@ write-file throw
   r> close-file throw
;

\ For testing, decompress the compressed image and print it to the console.

variable tally
variable ddims                          \ height:width
create hexdigs ," .123456789ABCDE#"
: .pix  ( n -- )                        \ output a pixel
   tally @  ddims c@  mod 0= if cr then
   1 tally +!  15 and hexdigs 1+ + c@ emit
;
: .1bpp  ( x -- x' )
   dup 1 and 0<> 15 and .pix  1 rshift
;
: pint  ( u16 -- )                      \ generate a run of pixels from command
   dup $8000 and if                     \ format: 1xxxxxxx_xxxxxxxx
      15 0 do  .1bpp  loop drop  exit   \ 15 x 1bpp
   then
   dup $E000 and $2000 = if             \ format: 001ccccx_xxxxxxxx
      dup 9 rshift 15 and               \ cnt x 1bpp
      0 ?do  .1bpp  loop drop  exit
   then
   dup $F000 and $4000 = if             \ format: 0100aaaa_aabbbbbb
      4095 and 64 /mod  ( b a )
      0 ?do  0 .pix  loop
      0 ?do 15 .pix  loop  exit
   then
   dup $F800 and $5000 = if             \ format: 01010ggg_gccccccc  gray, 0s
      $7FF and $80 /mod  .pix
      0 ?do  0 .pix  loop  exit
   then
   dup $F800 and $5800 = if             \ format: 01011ggg_gccccccc  gray, Fs
      $7FF and $80 /mod  .pix
      0 ?do 15 .pix  loop  exit
   then
   drop ." ?"
;

: decompress  ( addr -- )               \ test the compressed image
   wcount ddims w!
   wcount  cr dup . ." 16-bit words"
   0 tally !
   0 ?do  wcount pint
   loop  drop
;

: dum  ( -- )                           \ dump compressed data in hex
   compbuf wcount  cr dup . ." words"
   0 ?do  wcount i @ 7 and  if cr then  h.
   loop  drop
;

\ Look up a glyph in the font table, return the address of the bitmap data
\ relative to FontHome.

: faddr  ( xchar -- addr | 0 )
   >r
   FontHome  count FontID @ > 0= abort" Invalid FontID"
   FontID @ 3 * +  n@  FontHome +       \ 'tables for this FontID
   dup  r@ 6 rshift 2* +  w@  dup if    ( 'fine offset )
      + count  r> $3F and               ( 'glyphs max index )
      tuck > 0= if  2drop 0 exit  then  \ beyond the end
      3 * + n@  exit
   then  r> drop                        \ fine table does not exist
;
: try  ( xc -- )                        \ dump a char from the font database
   faddr ?dup if
      FontHome +  cr ." left=" count . ." top=" count .
      dup c@ ." width=" .  dup 1+ c@ ." height=" .
      decompress
   then
;

\ =============================================================================
\ Command dispatch

: CSPEC-CLOSE  ( -- res )
   [DEFINED] DISCONNECT [IF] DISCONNECT [THEN]
   hDlg DestroyWindow  0 ;  \ close dialog & console

: DLG-DESTROY  ( -- res )
   0 PostQuitMessage  0 ;

[SWITCH CSPEC-COMMANDS ZERO  ( -- res )
   IDCANCEL         RUN: CSPEC-CLOSE ;
SWITCH]

[SWITCH CSPEC-MESSAGES ZERO
   WM_DESTROY       RUNS DLG-DESTROY
   WM_CLOSE         RUNS CSPEC-CLOSE
   WM_INITDIALOG    RUN: -1 ;
   WM_COMMAND       RUN: ( -- res )  WPARAM LOWORD CSPEC-COMMANDS ;
SWITCH]

VARIABLE MINDEPTH  20 MINDEPTH !
VARIABLE MAXDEPTH   0 MAXDEPTH !

: DD  \ dump depths: sanity check of stack depths after commands
   MINDEPTH ? MAXDEPTH ? ;

:NONAME  ( -- res )
   MSG LOWORD CSPEC-MESSAGES
   DEPTH MAXDEPTH @ MAX MAXDEPTH !
   DEPTH MINDEPTH @ MIN MINDEPTH !
   BEGIN DEPTH 1 > WHILE NIP REPEAT
; 4 CB: RUNCSPEC

: GO            ( -- )
   HINST (CSPEC)  0 RUNCSPEC 0 CreateDialogIndirectParam TO hDlg
   hDlg GetDC TO HDC
   DUP SW_SHOWDEFAULT ShowWindow DROP
   InitGraf
;
GO

\ ==============================================================================
\ populate the "used chars" list

HEX
\ UTF-8 input uses a FSM to turn bytes into xchars.
\ +CHAR returns true when a valid xchar has been assembled.

0 VALUE InFile
VARIABLE UTFCHAR
VARIABLE UTFSTATE

: +CHAR  ( c -- flag )      \ take in character, flag=1 if ready
   DUP 80 AND IF
      DUP C0 <              \ extension of UTF8
      IF  3F AND  UTFCHAR @ 6 LSHIFT
          OR      UTFCHAR !
          -1 UTFSTATE +!  UTFSTATE @ 0=
      ELSE
         DUP E0 < IF        \ 2-character UTF8
            1F AND UTFCHAR !  1 UTFSTATE !
            FALSE EXIT
         THEN
         DUP F0 < IF        \ 3-character UTF8
            0F AND UTFCHAR !  2 UTFSTATE !
            FALSE EXIT
         ELSE
            7 AND UTFCHAR !   3 UTFSTATE !
            FALSE EXIT
         THEN
      THEN
   ELSE                     \ ASCII character
      UTFCHAR !  TRUE       \ little endian store
   THEN
;

DECIMAL

variable temp
: MSGfile  ( <filename> -- )    \ tag used xchars in 16-bit range
   parse-word r/o open-file throw to InFile
   begin
      temp 1 InFile read-file throw
   while
      temp c@ +CHAR IF
         UTFCHAR @
         dup |usedchars| >= abort" UTF char above 65535"
         dup $FEFF = if drop else       \ ignore BOM marker
            [usedchars]  1 swap !       \ tag this char as used
         then
      THEN
   repeat
   InFile close-file throw
;

\ Typical usage:
\ FW_REGULAR to f_weight

\ 1 /FONTS
\ /msg HasNumeric
\ H4 MakeFont
\ 0 maketable
\ cr fhere . .( bytes of data in font 0)
\ save myfont.bin

\ char 3 try


